erd notations (crow foot notation simbols)
uml notations

Была выбрана реляционная бд, поскольку для линейного приложения (не-граф) она быстрее.

Автосохранение происходит часто, и обновление всего текста обойдется дорого. Поэтому текст разбит на небольшие фрагменты
(TextPart), при написании заметок происходит авторазбивка и автосохранение фрагментов.

При получении текста из бд целый текст восстанавливается из фрагментов. Проблема была в том, что по id отсортировать
фрагменты невозможно, поскольку фрагменты могли быть вставлены в середину или уничтожены и т.п. Следовательно, необходима
какая-то индексация.
Индексы могли бы храниться в отдельной сущности со связью One-To-Many с фрагментами, в упорядоченной коллекции. Однако,
если использовать @EmbeddedCollection, то хибернейт будет при каждом обновлении уничтожать таблицу, в которую записана
эта коллекция с индексами, и заново ее создавать - дорого.
Можно было бы превращать коллекцию в стринг, сохранять его одной записью, а при получении снова превращать в коллекцию.
Но при частом сохранении это тоже дорого.
Поэтому был выбран принцип, по которому построен LinkedList: каждая запись содержит ссылку на предыдущую и последующую,
и при каждом автосохранении сохраняется только данный фрагмент, и только если у него изменился порядок - еще и
предыдущий, или последующий, или оба.

-----------------------------------------------------------

список textPart id по порядку хранится на сервере в объекте TextPartControllerTransientDataRepo, и клиенту не показывается.
Клиент знает только номера страниц, которые он запрашивал, и линки на первую - предыдущую - селф - следующую - последнюю,
плюс last modified ссылки

когда нарушил рест-констрейнт "сервер не знает о клиенте", начали стремительно плодиться классы...


--------------------------------------------------------

по js: метод updateBookmarks() привязан к success метода extractPage(), поскольку глобальная переменная totalPages обновляется
именно в случае успеха extractPage(), а updateBookmarks() ее использует (вообще-то, стоило бы получать totalPages на сервере,
тогда не было бы необходимости делать эту привязку, но: - бесполезно обновлять букмарки, пока не обновилось содержание страницы,
и эти два метода все равно, скорее всего, выполнятся в очереди, а не одновременно; - и тогда пришлось бы на сервере объединять
в одном методе контроллера вызов страницы и вызов букмарков)

----------------------------------------------------------------

недостатки: конструкция очень хрупкая, если случайно удалить одну из записей страниц (textPart) так, что nextItem у
предыдущей не будет обновлен, то уже невозможно будет восстановить последовательность страниц


-----------------------------
(try to learn gitk)