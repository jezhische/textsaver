erd notations (crow foot notation simbols)
uml notations

Была выбрана реляционная бд, поскольку для линейного приложения (не-граф) она быстрее.

Автосохранение происходит часто, и обновление всего текста обойдется дорого. Поэтому текст разбит на небольшие фрагменты
(TextPart), при написании заметок происходит авторазбивка и автосохранение фрагментов.

При получении текста из бд целый текст восстанавливается из фрагментов. Проблема была в том, что по id отсортировать
фрагменты невозможно, поскольку фрагменты могли быть вставлены в середину или уничтожены и т.п. Следовательно, необходима
какая-то индексация.
Индексы могли бы храниться в отдельной сущности со связью One-To-Many с фрагментами, в упорядоченной коллекции. Однако,
если использовать @EmbeddedCollection, то хибернейт будет при каждом обновлении уничтожать таблицу, в которую записана
эта коллекция с индексами, и заново ее создавать - дорого.
Можно было бы превращать коллекцию в стринг, сохранять его одной записью, а при получении снова превращать в коллекцию.
Но при частом сохранении это тоже дорого.
Поэтому был выбран принцип, по которому построен LinkedList: каждая запись содержит ссылку на предыдущую и последующую,
и при каждом автосохранении сохраняется только данный фрагмент, и только если у него изменился порядок - еще и
предыдущий, или последующий, или оба.

-----------------------------------------------------------

список textPart id по порядку хранится на сервере в объекте TextPartControllerTransientDataRepo, и клиенту не показывается.
Клиент знает только номера страниц, которые он запрашивал, и линки на первую - предыдущую - селф - следующую - последнюю,
плюс last modified ссылки